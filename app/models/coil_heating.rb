class CoilHeating
  include Mongoid::Document
  include Mongoid::Timestamps

  field :name, type: String
  field :type, type: String
  field :fuel_source, type: String
  field :fluid_segment_in_reference, type: String
  field :fluid_segment_out_reference, type: String
  field :fluid_flow_rate_design, type: Float
  field :capacity_total_gross_rated, type: Float
  field :capacity_total_net_rated, type: Float
  field :furnace_afue, type: Float
  field :furnace_thermal_efficiency, type: Float
  field :furnace_ignition_type, type: String
  field :furnace_pilot_fuel_input, type: Float
  field :condenser_type, type: String
  field :heat_pump_hspf, type: Float
  field :heat_pump_cop, type: Float
  field :heat_pump_supplemental_coil_heating_reference, type: String
  field :heat_pump_compressor_lockout_temperature, type: Float
  field :heat_pump_supplemental_temperature, type: Float
  field :heat_pump_crankcase_heat_capacity, type: Float
  field :heat_pump_crankcase_control_temperature, type: Float
  field :heat_pump_defrost_heat_source, type: String
  field :heat_pump_defrost_heat_capacity, type: Float
  field :heat_pump_defrost_control, type: String
  field :auxilliary_power, type: Float

  belongs_to :air_segment
  belongs_to :zone_system
  belongs_to :terminal_unit

  def self.children_models
    children = [

    ]
  end

  def self.xml_fields
    xml_fields = [
      { db_field_name: 'name', xml_field_name: 'Name' },
      { db_field_name: 'type', xml_field_name: 'Type' },
      { db_field_name: 'fuel_source', xml_field_name: 'FuelSrc' },
      { db_field_name: 'fluid_segment_in_reference', xml_field_name: 'FluidSegInRef' },
      { db_field_name: 'fluid_segment_out_reference', xml_field_name: 'FluidSegOutRef' },
      { db_field_name: 'fluid_flow_rate_design', xml_field_name: 'FluidFlowRtDsgn' },
      { db_field_name: 'capacity_total_gross_rated', xml_field_name: 'CapTotGrossRtd' },
      { db_field_name: 'capacity_total_net_rated', xml_field_name: 'CapTotNetRtd' },
      { db_field_name: 'furnace_afue', xml_field_name: 'FurnAFUE' },
      { db_field_name: 'furnace_thermal_efficiency', xml_field_name: 'FurnThrmlEff' },
      { db_field_name: 'furnace_ignition_type', xml_field_name: 'FurnIgnType' },
      { db_field_name: 'furnace_pilot_fuel_input', xml_field_name: 'FurnPilotFuelInp' },
      { db_field_name: 'condenser_type', xml_field_name: 'CndsrType' },
      { db_field_name: 'heat_pump_hspf', xml_field_name: 'HtPumpHSPF' },
      { db_field_name: 'heat_pump_cop', xml_field_name: 'HtPumpCOP' },
      { db_field_name: 'heat_pump_supplemental_coil_heating_reference', xml_field_name: 'HtPumpSuppCoilHtgRef' },
      { db_field_name: 'heat_pump_compressor_lockout_temperature', xml_field_name: 'HtPumpCprsrLockoutTemp' },
      { db_field_name: 'heat_pump_supplemental_temperature', xml_field_name: 'HtPumpSuppTemp' },
      { db_field_name: 'heat_pump_crankcase_heat_capacity', xml_field_name: 'HtPumpCrankcaseHtrCap' },
      { db_field_name: 'heat_pump_crankcase_control_temperature', xml_field_name: 'HtPumpCrankcaseCtrlTemp' },
      { db_field_name: 'heat_pump_defrost_heat_source', xml_field_name: 'HtPumpDefHtSrc' },
      { db_field_name: 'heat_pump_defrost_heat_capacity', xml_field_name: 'HtPumpDefHtrCap' },
      { db_field_name: 'heat_pump_defrost_control', xml_field_name: 'HtPumpDefCtrl' },
      { db_field_name: 'auxilliary_power', xml_field_name: 'AuxPwr' }
    ]
  end

  # This method is autogenerated. Do not change directly.
  def to_sdd_xml(meta, xml)
    xml.send(meta[:xml_name]) do
      self.class.xml_fields.each do |field|
        if self[field[:db_field_name]]
          if self[field[:db_field_name]].is_a? Array
            logger.debug 'Translating to XML and the object is an Array'
            self[field[:db_field_name]].each_with_index do |instance, index|
              xml.send(:"#{field[:xml_field_name]}", instance, 'index' => index)
            end
          else
            xml.send(:"#{field[:xml_field_name]}", self[field[:db_field_name]])
          end
        end
      end

      # go through children if they have something to add, call their methods
      kids = self.class.children_models
      unless kids.nil? || kids.empty?
        kids.each do |k|
          models = send(k[:model_name].pluralize)
          models.each do |m|
            m.to_sdd_xml(k, xml)
          end
        end
      end
    end
  end

  # This method is autogenerated. Do not change directly.
  # Take the map of model name and xml name, and the hash (from the XML).
  def self.from_sdd_json(meta, h)
    o = nil
    if meta && h
      self_model = meta[:model_name].camelcase(:upper).constantize
      o = self_model.create_from_sdd_json(meta, h)
      if o
        o.create_children_from_sdd_json(meta, h)
        o.save!
        o.reload # in case of relationships being updated
      else
        fail "Could not create instance of #{self_model} for #{meta[:model_name]}"
      end
    end

    o
  end

  # This method is autogenerated. Do not change directly.
  def self.create_from_sdd_json(meta, h)
    new_h = {}

    # Find fields as defined by the XML
    self_model = meta[:model_name].camelcase(:upper).constantize
    self_model.xml_fields.each do |field|
      if h[field[:xml_field_name]]
        logger.debug "Field Data Type: #{self_model.fields[field[:db_field_name]].options[:type]}"
        if self_model.fields[field[:db_field_name]].options[:type].to_s == 'Array'
          logger.debug 'Data model has an array as the field'
          # check if the hash has an array, otherwise make it an array
          if h[field[:xml_field_name]].is_a? Array
            logger.debug 'XML/JSON field is already an Array'
            new_h[field[:db_field_name]] = h[field[:xml_field_name]]
          else
            new_h[field[:db_field_name]] = [h[field[:xml_field_name]]]
          end
        else
          new_h[field[:db_field_name]] = h[field[:xml_field_name]]
        end
      end
    end

    # new_h can be empty if the xml has no fields, but still create the object
    o = self_model.new(new_h)

    o
  end

  # This method is autogenerated. Do not change directly.
  def create_children_from_sdd_json(meta, h)
    # Go through the children
    self_model = meta[:model_name].camelcase(:upper).constantize
    kids = self_model.children_models
    unless kids.nil? || kids.empty?
      kids.each do |k|
        # check if the kids have a json object at this level
        if h[k[:xml_name]]
          logger.debug "XML child is #{k[:xml_name]}"
          logger.debug "Model name is #{k[:model_name]}"
          if h[k[:xml_name]].is_a? Array
            logger.debug "#{k[:xml_name]} is an array, will add all the objects"
            h[k[:xml_name]].each do |h_instance|
              klass = k[:model_name].camelcase(:upper).constantize
              if klass.respond_to? :from_sdd_json
                model = klass.from_sdd_json(k, h_instance)

                # Assign the foreign key on the object
                model["#{meta[:model_name]}_id"] = id
                model.save!
              else
                logger.warn "Class #{klass} does not have instance method 'from_sdd_json'"
              end
            end
          elsif h[k[:xml_name]].is_a? Hash
            logger.debug "#{k[:xml_name]} is a single object, will add only one"
            klass = k[:model_name].camelcase(:upper).constantize
            if klass.respond_to? :from_sdd_json
              model = klass.from_sdd_json(k, h[k[:xml_name]])

              # Assign the foreign key on the object
              model["#{meta[:model_name]}_id"] = id
              model.save!
            else
              logger.warn "Class #{klass} does not have instance method 'from_sdd_json'"
            end
          end
        end
      end
    end
  end

  def type_enums
    [
      '- specify -',
      'Resistance',
      'Furnace',
      'HeatPump',
      'HotWater'
    ]
  end

  def fuel_source_enums
    [
      '- specify -',
      'Electric',
      'NaturalGas',
      'Oil'
    ]
  end

  def furnace_ignition_type_enums
    %w(IntermittentIgnitionDevice PilotLight)
  end

  def condenser_type_enums
    %w(Air WaterSource)
  end

  def heat_pump_defrost_heat_source_enums
    %w(Electric HotGas)
  end

  def heat_pump_defrost_control_enums
    %w(OnDemand TimedCycle)
  end
end
